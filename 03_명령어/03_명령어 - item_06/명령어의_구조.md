# 3-2. 명령어의 구조

이번 절에서는 하나의 명령어를 자세히 들여다 보며 **연산 코드, 오퍼랜드, 주소 지정 방식**이라는 개념을 학습한다.

## 연산 코드와 오퍼랜드

컴퓨터 속 명령어는 '무엇을 대상으로, 어떤 작동을 수행하라' 라는 구조로 구성되어 있다. 즉, 명령어는 **연산 코드(Operation Code)**와 **오퍼랜드(Operand)**로 구성되어 있다.

-   **연산 코드**: 명령어가 수행할 연산 (연산자)
-   **오퍼랜드**: 연산에 사용할 데이터 또는 데이터가 저장된 위치 (피연산자)

연산 코드가 담기는 영역을 **연산 코드 필드**, 오퍼랜드가 담기는 영역을 **오퍼랜드 필드**라고 부른다. 기계어와 어셈블리어 또한 명령어이기 때문에 연산 코드와 오퍼랜드로 구성되어 있다.

### 오퍼랜드

오퍼랜드는 '연산에 사용할 데이터' 또는 '연산에 사용할 데이터가 저장된 위치'를 의미한다. 따라서 오퍼랜드 필드에는 숫자나 문자 등을 나타내는 **데이터** 또는 **메모리나 레지스터 주소**가 올 수 있다.

다만 오퍼랜드 필드에는 데이터 자체를 직접 명시하기보다는, 많은 경우 데이터가 저장된 위치, 즉 **메모리 주소나 레지스터 이름**이 담긴다. 이 때문에 오퍼랜드 필드를 **주소 필드**라고 부르기도 한다.

오퍼랜드는 개수에 따라 아래와 같이 분류할 수 있다.
- **0-주소 명령어**: 오퍼랜드가 없는 명령어
- **1-주소 명령어**: 오퍼랜드가 한 개인 명령어
- **2-주소 명령어**: 오퍼랜드가 두 개인 명령어

### 연산 코드

연산 코드는 명령어가 수행할 연산을 의미한다. 연산 코드의 종류는 매우 많지만 기본적인 유형은 크게 네 가지로 나눌 수 있다.

1.  **데이터 전송**
2.  **산술/논리 연산**
3.  **제어 흐름 변경**
4.  **입출력 제어**

각 유형에 해당하는 대표적인 연산 코드는 다음과 같다. (CPU마다 종류와 생김새가 다르므로 외울 필요는 없다.)

#### 데이터 전송
-   **MOVE**: 데이터를 옮겨라
-   **STORE**: 메모리에 저장하라
-   **LOAD (FETCH)**: 메모리에서 CPU로 데이터를 가져와라
-   **PUSH**: 스택에 데이터를 저장하라
-   **POP**: 스택의 최상단 데이터를 가져와라

#### 산술/논리 연산
-   **ADD / SUBTRACT / MULTIPLY / DIVIDE**
-   **INCREMENT / DECREMENT**: 오퍼랜드에 1을 더하거나 빼라
-   **AND / OR / NOT**: 논리 연산
-   **COMPARE**: 두 오퍼랜드를 비교하라

#### 제어 흐름 변경
-   **JUMP**: 특정 주소로 실행 순서를 옮겨라
-   **CONDITIONAL JUMP**: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
-   **HALT**: 프로그램의 실행을 멈춰라
-   **CALL**: 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
-   **RETURN**: `CALL`을 호출할 때 저장했던 주소로 돌아가라

#### 입출력 제어
-   **READ (INPUT)** / **WRITE (OUTPUT)**
-   **START IO** / **TEST IO**

---

## 주소 지정 방식

**왜 오퍼랜드 필드에 데이터가 아닌 메모리나 레지스터의 주소를 담는가?**

가장 큰 이유는 **명령어의 길이** 때문이다. 명령어의 길이는 한정되어 있는데, 오퍼랜드 필드에 데이터 자체를 넣으면 표현할 수 있는 값의 크기가 매우 제한된다. 하지만 오퍼랜드 필드에 **메모리 주소**를 담는다면, 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커지게 된다.

> 연산의 대상이 되는 데이터가 저장된 실제 위치를 **유효 주소(Effective Address)**라고 한다. 오퍼랜드 필드를 통해 유효 주소를 찾는 방법을 **주소 지정 방식(Addressing Mode)**이라고 한다.

대표적인 주소 지정 방식 다섯 가지는 다음과 같다.

### 1. 즉시 주소 지정 방식 (Immediate Addressing)
연산에 사용할 데이터를 오퍼랜드 필드에 **직접 명시**하는 방식이다. 메모리나 레지스터를 참조할 필요가 없어 **속도가 빠르지만**, 표현할 수 있는 **데이터의 크기가 작아진다**는 단점이 있다.

### 2. 직접 주소 지정 방식 (Direct Addressing)
오퍼랜드 필드에 **유효 주소를 직접 명시**하는 방식이다. 즉시 주소 지정 방식보다 큰 데이터를 다룰 수 있지만, 오퍼랜드 필드의 비트 수에 의해 **표현할 수 있는 주소의 범위가 제한**된다.

### 3. 간접 주소 지정 방식 (Indirect Addressing)
오퍼랜드 필드에 **유효 주소의 주소**를 명시하는 방식이다. 즉, 오퍼랜드가 가리키는 메모리 위치에 찾아가면, 그곳에 진짜 데이터의 주소가 저장되어 있다.

> **직접 주소 지정 방식과 무엇이 다른가?**
> 가장 큰 차이점은 **접근할 수 있는 메모리 주소의 범위**다. 예를 들어 오퍼랜드 필드가 16비트라면 직접 방식으로는 2^16개의 주소만 표현할 수 있다. 하지만 간접 방식을 사용하면, 16비트로 표현 가능한 주소에 찾아가 더 큰 주소 값(예: 32비트 주소)을 읽어올 수 있으므로 훨씬 넓은 범위의 메모리에 접근할 수 있다. 이 방식은 **두 번의 메모리 접근**이 필요해 속도가 느리다.

### 4. 레지스터 주소 지정 방식 (Register Addressing)
연산에 사용할 데이터를 저장한 **레지스터를 오퍼랜드 필드에 직접 명시**하는 방식이다. 메모리보다 훨씬 빠른 CPU 내부의 레지스터에 접근하므로 **속도가 매우 빠르다**. 하지만 사용할 수 있는 **레지스터의 개수가 매우 제한적**이라는 단점이 있다.

### 5. 레지스터 간접 주소 지정 방식 (Register Indirect Addressing)
유효 주소를 **레지스터에 저장**하고, 그 레지스터를 오퍼랜드 필드에 명시하는 방식이다. 간접 주소 지정 방식과 유사하지만, 유효 주소를 메모리가 아닌 레지스터에서 가져오므로 **메모리 접근을 한 번만** 하면 된다. 따라서 간접 주소 지정 방식보다 **속도가 빠르다**.