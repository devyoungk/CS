# 페이징을 통한 가상 메모리 관리

**가상 메모리** : 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행하는 기술
- **페이징**
- 세그멘테이션

---
## 페이징이란
**페이징** : 프로세스의 물리 주소 공간을 `프레임` 단위로 자르고, 프로세스의 논리 주소 공간을 `페이지` 단위로 자른 뒤 각 페이지를 프레임에 할당하는 가상 메모리 관리 기법  

페이징에서도 스와핑 사용 가능 (페이지 아웃, 페이지 인)
=> 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요 없다.  
=> 물리 메모리보다 더 큰 프로세스 실행 가능

---
## 페이지 테이블
페이징 시스템은 프로세스가 비록 물리 주소에 불연속적으로 배치되더라도 논리 주소에는 연속적으로 배치되도록 **페이지 테이블**을 이용한다.  
-> 현재 어떤 페이지가 어떤 프레임에 할당되었는지 알려준다.

**페이지 테이블 베이스 레지스터(PTBR)** : 각 프로세스의 페이지 테이블이 적재된 주소를 가리킨다.

페이지 테이블을 메모리에 두면-> 메모리 접근 시간 두 배 -> 어떻게 해결?   
**TLB**:  페이지 테이블의 캐시 메모리 역할을 수행하기 위해 페이지 테이블의 일부를 저장 (TLB 히트, 미스)

---
## 페이징에서의 주소 변환
특정 주소에 접근하기 위해서는 두 가지 정보 필요
- 어떤 페이지 혹은 프레임에 접근하고 싶은지
- 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지
  
=> 페이징 시스템에서 모든 논리 주소 **페이지 번호**와 **변위**로 이루어짐

---
## 페이지 테이블 엔트리
**페이지 테이블 엔트리**: 페이지 테이블의 각각의 행  
페이지 번호, 프레임 번호 이외에도 다른 중요한 정보 포함  

- **유효 비트** : 현재 해당 페이지에 접근 가능한지 여부
  - 유효 비트가 0인 페이지로 접근하려고 하면 **페이지 폴트**라는 예외 발생
- **보호 비트** : 페이지에 접근할 권한을 제한하여 페이지를 보호
- **참조 비트** : CPU가 페이지에 접근한 적이 있는지 여부
- **수정 비트** : 해당 페이지에 데이트를 쓴 적이 있는지 없는지 수정 여부

---
## ※ 참고
### 내부 단편화
프로세스가 필요로 하는 메모리보다 페이지 단위 할당이 커서 남는 사용되지 않는 공간.

### 쓰기 시 복사
- 부모 프로세스와 자식 프로세스가 메모리를 공유
- 읽기만 하면 그대로 공유
- 쓰기 작업을 하려고 하면 OS가 그 페이지를 복사 후 수정
→ 불필요한 메모리 복사를 줄이고 효율적으로 사용

### 계층적 페이징
페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식  
-> 모든 페이지 테이블을 항상 메모리에 유지할 필요 X

---
