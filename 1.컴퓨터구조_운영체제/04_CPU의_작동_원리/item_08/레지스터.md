
## **핵심 공통 레지스터 8가지**

CPU 내에서 연산과 데이터 처리를 담당하는 레지스터는 역할에 따라 다양하게 분류됨. 그중 대부분의 CPU가 공통으로 포함하는 핵심적인 8가지 레지스터의 종류와 역할을 정리함.

---

### **1. 프로그램 카운터 (Program Counter, PC)**

- 다음에 실행할 **명령어의 메모리 주소**를 저장하는 레지스터
    
- CPU가 명령어 하나를 실행할 때마다 PC의 값이 자동으로 증가하여 다음 명령어를 순서대로 가져올 수 있게 함.
    
- 비유하자면, 책을 읽을 때 다음 페이지를 가리키는 **책갈피**와 같음.
	→ 그래서인지 **명령어 포인터**라고 부르기도 함.
    

### **2. 명령어 레지스터 (Instruction Register, IR)**

- 현재 CPU가 **실행하고 있는 명령어 코드**를 저장하는 레지스터
    
- 메모리에서 인출(Fetch)된 명령어가 이곳에 임시로 저장되며, 제어장치가 이 명령어를 해석(Decode)하여 실행에 필요한 제어 신호를 생성하고 내보냄.
    

### **3. 메모리 주소 레지스터 (Memory Address Register, MAR)**

- CPU가 메모리에서 데이터를 읽거나 쓸 때 **접근하려는 주소**를 저장하는 레지스터
    
- CPU가 데이터를 요청하면, **MAR**에 주소를 넣고 메모리 컨트롤러에 명령을 내림.
    

### **4. 메모리 버퍼 레지스터 (Memory Buffer Register, MBR)**

- CPU와 메모리 사이에서 **실제 데이터**를 임시로 저장하는 레지스터
    
- 메모리에서 읽어온 데이터나 메모리에 써야 할 데이터가 이곳에 머뭄.
    
- **MAR**이 '주소'를 담당한다면, **MBR**은 그 주소에 해당하는 '데이터'를 담당함.
    

### **5. 플래그 레지스터 (Flag Register)**

- ALU 연산 결과에 대한 **상태 정보**(플래그)를 저장하는 레지스터
    
- 예를 들어, 연산 결과가 0인지, 음수인지, 오버플로우가 발생했는지 등을 나타내는 1비트의 스위치들로 구성됨. 제어장치가 이 정보를 활용하여 조건 분기문(예: `if-else`)을 실행함.
    
- **예시:** `3 - 3` 연산 결과가 0일 경우, Zero Flag가 1로 설정되어 제어장치는 이 정보를 바탕으로 다음 명령을 결정함.
    

### **6. 범용 레지스터 (General Purpose Register, GPR)**

- 연산에 필요한 데이터를 임시로 저장하는 레지스터
    
- 프로그래머가 직접 조작할 수 있으며, 연산의 피연산자나 중간 결과를 저장하는 등 다양한 용도로 사용됨.
    
- **예시:** `int a = 10; int b = 20;` 코드를 실행할 때, `10`과 `20`이라는 값이 일시적으로 범용 레지스터에 저장되었다가 연산에 사용됨됨.
    

### **7. 스택 포인터 (Stack Pointer, SP)**

- 스택(Stack) 메모리 구조에서 **스택의 최상단 주소**를 저장하는 레지스터
    
- 함수 호출 시 인자, 지역 변수, 복귀 주소 등을 스택에 저장(Push)하고, 함수가 끝나면 다시 꺼내(Pop)는 데 사용됨.
    
- **주소 값 조정**: 스택은 일반적으로 **높은 주소에서 낮은 주소로 자라나는** Grow 구조를 가집니다. 따라서 스택에 데이터를 **`Push`할 때 SP의 값은 감소**하고, 데이터를 **`Pop`할 때 SP의 값은 증가**함.
    

### **8. 베이스 레지스터 (Base Register)**

- 프로그램의 기준이 되는 **기준 주소**를 저장하는 레지스터
    
- 베이스 레지스터는 명령어에 포함된 **상대주소**(Offset)와 결합하여 실제 메모리 주소를 계산하는 데 사용됨.
    
- **예시**: 베이스 레지스터의 값이 `1000h`이고, 명령어에 `ADD R1, 50h`가 있다면, CPU는 `1000h + 50h = 1050h`와 같이 계산하여 `1050h` 주소의 데이터를 가져옴.
    
- 이러한 방식을 통해 프로그램은 메모리의 어느 위치에 로드되어도 올바르게 실행될 수 있으며, 이를 **재배치성**(Relocatability)이라고 함.
    
---

### **레지스터를 활용한 명령어 실행 예시**

아래는 `ADD R1, R2, R3` (R2와 R3 레지스터의 값을 더해 R1에 저장하라)와 같은 간단한 명령어가 어떻게 처리되는지 보여주는 예시임.

1. **인출 (Fetch)**: **PC**가 가리키는 주소에서 `ADD R1, R2, R3` 명령어를 가져와 **IR**에 저장함.
    
2. **해석 (Decode)**: **제어장치**는 **IR**의 내용을 해석하고, 이것이 '덧셈' 연산임을 파악함. 또한, 연산에 필요한 데이터가 **범용 레지스터**(R2, R3)에 있다는 것을 알아냄.
    
3. **데이터 인출**: **제어장치**가 **R2**와 **R3**의 값을 **ALU**로 보냄.
    
4. **실행 (Execute)**: **ALU**가 두 레지스터의 값을 더하고, 그 결과가 **플래그 레지스터**에 반영됨.
    
5. **저장 (Store)**: **ALU**가 계산한 결과를 **R1**에 저장함.
    

이 과정에서 **PC**는 다음 명령어 주소로 업데이트되어 다음 명령을 준비함.
