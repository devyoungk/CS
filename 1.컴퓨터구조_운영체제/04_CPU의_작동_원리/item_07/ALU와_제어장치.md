## **ALU (Arithmetic Logic Unit)**

- CPU의 핵심 부품
- 모든 **산술 연산**과 **논리 연산** 담당
- 비유하자면, 컴퓨터의 두뇌 속 '계산기' 역할

---

## **ALU의 동작 과정**

ALU는 다음 네 단계를 거쳐 연산을 처리함. 실제로는 훨씬 더 세분화된 마이크로 연산이 여러 클럭 주기에 걸쳐 복잡하게 진행되오나, 과정을 단순화하여 데이터와 명령어가 어떤 흐름으로 ALU를 거쳐 처리되는지를 직관적으로 파악하는 것에 의의를 둠.

"예를 들어, `명령어 인출 > 명령어 해석 > 피연산자 주소 계산 > 피연산자 인출 > 연산 수행 > 결과 저장` 등 다양한 미세 단계로 나누어 볼 수도 있음."

1. **명령 전달**: 제어장치가 ALU에 연산 명령을 보냄.
	→ "덧셈을 수행하라" 명령
        
2. **데이터 전달**: ALU가 연산에 필요한 데이터를 레지스터에서 가져옴.
	→ 피연산자 `1`, `2` 획득
        
3. **연산 수행**: ALU가 전달받은 명령과 데이터를 바탕으로 연산을 처리함.
	→ 가산기 회로가 `1 + 2`를 계산하여 결과 `3` 도출
        
4. **결과 저장**: 연산 결과를 다시 레지스터에 저장함.
	→ 결과 `3`은 다음 연산을 위해 레지스터 저장
        

> **레지스터에 먼저 저장하는 이유**: 레지스터는 CPU 내부에 있어 메모리(RAM)보다 훨씬 빠르다. 연산 결과를 레지스터에 임시로 저장하면 다음 연산을 바로 이어서 수행할 수 있어, 프로그램 실행 속도를 크게 높일 수 있다.

---

## **ALU 내부의 주요 회로와 플래그**

### **주요 회로**

ALU는 다양한 기능 회로로 구성되어 실제 연산을 수행함. CPU마다 설계 방식이나 명령어 집합이 다르기 때문에 특정 고급 ALU에는 특수 연산 회로가 포함될 수 있으나, 보편적인 구성 요소는 `가산기, 보수기, 논리 회로, 시프터, 오버플로우 검출기, 증가기/감소기, 비교기, 비트 조작 회로` 정도임.

- **보수기 (Complementer)**: 뺄셈 연산을 위해 숫자를 2의 보수 형태로 바꿈.
    
    - **예시**: 뺄셈 `7 - 3`은 컴퓨터 내부적으로 `7 + (-3)`과 같이 덧셈으로 처리됨. 이때 보수기가 `-3`을 2의 보수 형태로 변환해줌.
        
- **시프터 (Shifter)**: 비트를 왼쪽이나 오른쪽으로 이동시켜 곱셈/나눗셈을 빠르게 처리함.
    
    - **예시**: `2 * 8`을 계산할 때, `8`의 이진수 `1000`을 왼쪽으로 1칸 옮기면 `10000`(16)이 되며, 이는 `8 * 2`의 결과와 같음.
        
- **오버플로우 검출기 (Overflow Detector)**: 연산 결과가 데이터 범위를 초과했는지 감지함.
    

### **주요 플래그**

플래그는 연산 결과에 대한 상태 정보를 저장하는 비트(bit)임. 조금 더 자세히 말하자면, **'플래그 레지스터'라는 특수 레지스터에 저장되는 1비트의 정보**이며, 각 플래그는 특정 조건이 충족되었는지를 나타내는 **단순한 스위치** 역할로 이해하면 쉬움.

| 플래그 이름                  | 역할                                    |
| ----------------------- | ------------------------------------- |
| **Zero Flag (ZF)**      | 연산 결과가 **0**일 때 1로 설정됨.               |
| **Sign Flag (SF)**      | 연산 결과가 **음수**일 때 1로 설정됨.              |
| **Overflow Flag (OF)**  | 부호 있는 정수 연산에서 **범위를 초과**했을 때 1로 설정됨.  |
| **Carry Flag (CF)**     | 부호 없는 정수 연산에서 **올림수**가 발생했을 때 1로 설정됨. |
| **Interrupt Flag (IF)** | **인터럽트**를 허용할 경우 1로 설정됨.              |
| **Supervisor Flag**     | 현재 CPU가 **커널모드**에서 실행 중이면 1로 설정됨.     |

---

## **제어 장치 (Control Unit)**

제어 장치는 CPU의 모든 장치에 **명령**을 내리고, 그 동작을 **통제**하는 핵심 부품임. CPU를 구성하는 부품들이 올바른 순서대로 작동하도록 조율하는 '교통경찰' 역할이라고 할 수 있음.

- **역할**: 명령어를 해석하고, 각 부품을 제어하는 **제어 신호**를 발생시킴.
    
- **특징**: 매우 정교하게 설계되며, 제조사마다 명령어 해석 방식이나 구현 방식이 다름. 따라서 제어 장치의 세부 구조보다는 그 **역할과 흐름**을 이해하는 것이 중요함.
    

### **제어장치의 데이터 흐름**

제어장치는 다양한 입력 신호를 받아들여 제어 신호를 내보냄. 제어장치가 받아들이는 신호 중 하나가 **클럭**이며, 클럭은 모든 부품들에 대한 시간 단위임. 엄밀히 **시간 단위**이기 때문에, 한 클럭당 한 움직임을 한다는 의미는 아님.

- **입력 (Inputs)**:
    
    - **명령어 레지스터**: 현재 실행 중인 명령어 코드(**해석할 명령어**)를 가져옴.
        
    - **플래그 레지스터**: ALU 연산의 결과(**플래그**)를 받아들여 다음 명령을 결정하는 데 활용함.
        
    - **클럭**: 컴퓨터의 모든 동작을 동기화하는 **클럭 신호**를 받음.
        
    - **제어 버스**: 외부 장치(메모리, I/O 장치 등)로부터 **제어 신호**를 받음.
        
- **출력 (Outputs)**:
    
    - **제어 신호**(CPU 내부): 연산 장치(ALU), 레지스터, 메모리 등 각 부품에 필요한 **제어 신호**를 보냄. 예를 들어, "데이터를 읽어라", "덧셈을 수행하라" 같은 명령이 여기에 해당함.
        
    - **제어 버스**(CPU 외부): 외부 장치(메모리, 입출력장치)로 **제어 신호**를 보냄.
        

---

## **명령어의 실행 과정 (Fech-Decode-Execute Cycle)**

아래는 제어 장치가 어떻게 작동하는지 이해하기 위해 CPU가 명령어를 실행하는 3단계 과정임.

1. **인출 (Fetch)**: 제어장치는 프로그램 카운터(PC)가 가리키는 메모리 주소에서 명령어를 가져와 명령어 레지스터(IR)에 저장함.
    
2. **해석 (Decode)**: 제어 장치는 명령어 레지스터에 저장된 명령어(Instruction)를 해석함. 이 과정에서 어떤 연산을 수행해야 하는지, 어떤 데이터가 필요한지 등을 파악함.
    
3. **실행 (Execute)**: 해석된 내용을 바탕으로 제어 장치는 각 부품(ALU, 레지스터 등)에 필요한 **제어 신호**를 보냄. 예를 들어, 덧셈 명령어라면 ALU에 덧셈 신호를 보내고, 필요한 데이터를 레지스터에서 가져오라는 신호를 함께 보냄.
    

---

## **추가로 알면 좋은 점**

- **마이크로코드 (Microcode)**: 대부분의 현대 CPU 제어 장치는 하드웨어적으로 고정된 방식(Hardwired Control)과 마이크로코드를 사용하는 방식(Microprogrammed Control)을 혼합하여 사용함. 마이크로코드는 복잡한 명령어를 더 단순한 여러 단계의 동작(Micro-operation)으로 쪼개어 제어하는 소프트웨어적인 방식임. 이러한 방식은 복잡한 명령어 구조를 유연하게 지원하고, 버그 수정이나 기능 추가를 용이하게 한다는 장점이 있음.
    
