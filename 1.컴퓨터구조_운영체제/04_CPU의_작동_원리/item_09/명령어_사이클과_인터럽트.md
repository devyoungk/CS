## **명령어 사이클 (Instruction Cycle)**

CPU가 하나의 명령어를 처리하는 전체 과정인 **명령어 사이클**은 크게 **인출 사이클**과 **실행 사이클**로 나뉨. CPU는 이 두 사이클을 끊임없이 반복하며 프로그램을 실행함.

#### **1) 인출 사이클 (Fetch Cycle)**

- **목표**: 메모리에서 다음에 실행할 명령어를 CPU로 가져오는 단계
    
- **과정**:
    
    1. **프로그램 카운터**(PC)에 저장된 다음 명령어의 주소가 **메모리 주소 레지스터**(MAR)로 전달됨.
        
    2. 메모리에서 해당 주소의 명령어를 읽어와 **메모리 버퍼 레지스터**(MBR)에 임시 저장함.
        
    3. MBR의 내용이 **명령어 레지스터**(IR)로 옮겨짐.
        
    4. 다음 명령어를 위해 PC의 값이 자동으로 증가함.
        

#### **2) 실행 사이클 (Execute Cycle)**

- **목표**: 인출된 명령어를 CPU가 처리하는 단계
    
- **과정**:
    
    1. **제어장치**가 **IR**에 담긴 명령어를 해석하여 어떤 연산을 수행해야 하는지 파악함.
        
    2. 해석된 내용에 따라 제어장치가 **ALU**, **레지스터**, **메모리** 등에 필요한 제어 신호를 발생시킴.
        
    3. 예를 들어, `ADD` 명령어라면 ALU에 덧셈 신호를 보내고, 필요한 데이터를 레지스터에서 가져오라고 지시함.
        

#### **간접 사이클과 자바 참조**

명령어가 피연산자의 주소를 직접 포함하지 않고, 피연산자의 주소를 담고 있는 **주소의 주소**를 가리킬 때 **간접 사이클**이 추가됨. 이는 자바의 **참조 변수**와 매우 유사한 개념임. 이 경우 명령어는 실제 데이터가 있는 곳을 직접 가리키는 것이 아니라, 데이터의 위치를 알려주는 주소(참조)를 가리키므로, CPU는 실제 데이터에 접근하기 위해 한 단계 더 거치는 과정이 필요함.

> 즉, 인출 사이클과 실행 사이클 사이 간접 사이클이 존재하게 된다는 뜻임.

---

## **인터럽트**

인터럽트는 프로그램의 정상적인 흐름을 방해하는 비동기적 사건임. 이는 CPU가 외부 장치의 작업이 끝날 때까지 기다리는 **폴링(Polling)** 방식의 비효율성을 해결하기 위해 도입된 메커니즘임.

> 비유하자면, CPU가 **전자레인지나 세탁기에게 일을 시킨 후, 끝났는지 계속 쳐다보는 대신**(폴링), 종료음(인터럽트)이 울릴 때까지 다른 일을 하는 것과 같음. 이는 CPU를 효율적으로 사용하기 위함임. 

#### **인터럽트의 종류와 동기성**

- **하드웨어 인터럽트 (비동기적)**: 키보드 입력, 마우스 움직임, 프린터 작업 완료 등 외부 장치가 CPU에 작업을 요청할 때 발생함. 명령어 실행과 무관하게 언제든 발생할 수 있으므로 **비동기적**임.
    
- **소프트웨어 인터럽트 (동기적)**: 프로그램 내부에서 발생하며, CPU가 발생시킨다고 봐도 무방함.
    
    - **예외(Exception)**: 0으로 나누기, 잘못된 메모리 접근 등 프로그램 실행 중 오류가 발생할 때, **해당 명령어를 실행하는 시점에 동기적**으로 발생함.
        
    - **시스템 호출(System Call)**: 프로그램이 운영체제에 서비스를 요청할 때, **호출하는 시점에 동기적**으로 발생함.
        

#### **막을 수 없는 인터럽트: NMI**

대부분의 하드웨어 인터럽트는 **인터럽트 플래그**(Interrupt Flag)에 의해 제어되지만, **마스크 불가능 인터럽트**(Non-Maskable Interrupt, NMI)는 이 플래그로 막을 수 없는 특별한 인터럽트임. 이는 시스템의 치명적인 오류(예: 전원 공급 오류, 메모리 오류)를 알리기 위해 발생하며, CPU는 이를 반드시 처리해야 함.


## **인터럽트의 처리 과정**

**하나의 명령어 사이클이 끝난 후**, CPU는 다음 명령어를 인출하기 전에 항상 인터럽트 요청이 있는지 확인함. 요청이 있을 경우, 다음과 같은 순서로 인터럽트를 처리함.

1. **인터럽트 요청 발생 (Request)**: 외부 장치가 인터럽트 컨트롤러를 통해 CPU에 요청 신호를 보냄.
    
2. **인터럽트 플래그 확인 (Flag Check)**: CPU는 인터럽트 플래그가 활성화(1)되어 있는지 확인하여 요청을 수락할지 결정함.
    
3. **현재 상태 백업 (Backup)**: CPU는 현재 실행 중이던 작업의 상태(PC, 레지스터 값 등)를 **스택**에 저장함. → 인터럽트 처리 후 원래 작업으로 자연스럽게 복귀하기 위함임.
    
4. **인터럽트 벡터 테이블 접근 (Vector Check)**: CPU는 인터럽트 컨트롤러로부터 받은 **고유 번호**(인터럽트 번호)를 인덱스 삼아, **인터럽트 벡터 테이블**에서 해당 인터럽트를 처리할 **인터럽트 서비스 루틴**(ISR)의 시작 주소를 찾음.
    
    - **인터럽트 벡터(Interrupt Vector)**: ISR의 시작 주소를 가리키는 포인터임.
        
    - **인터럽트 서비스 루틴(ISR)**: **인터럽트 핸들러**라고도 불리며, **API처럼** 특정 인터럽트 요청을 어떻게 처리할지 정의된 **방침서**와 같은 '코드의 집합'임.
        
5. **핸들러 실행 (Execute)**: CPU는 찾은 ISR의 주소로 이동하여 인터럽트 핸들러 코드를 실행함.
    
6. **상태 복구 및 복귀 (Restore)**: 핸들러 실행이 끝나면, CPU는 **스택에 백업했던 상태를 복구**하고 중단되었던 명령어부터 원래 작업을 재개함.

#### 점검하기 (깜짝 퀴즈!)

하나의 명령어 사이클이 끝난 후, 새롭게 인출하기 전에 인터럽트 요청이 있는지 확인한다고 하였는데, **만약 인터럽트 플래그가 `0`이라면**, 인출 전 인터럽트 요청이 있는지 확인할까?

> 확인한다면 어떤 이유에서 확인할 것 같은지, 확인하지 않는다면 어떤 이유에서 확인하지 않을 것 같은지 설명해보자!
