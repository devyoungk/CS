## 동기화를 위한 도구

운영체제는 프로세스의 동기화를 어떻게 이루어지게 하는 걸까?

---

### **1. 뮤텍스 (Mutex, MUTual EXclusion)**

**핵심 개념:** 화장실이 **하나**뿐인 휴게소

* **동작 방식:**
  1. 임계 구역에 들어가기 위해 `acquire` (잠금 획득)을 시도
  2. 만약 잠금이 이미 다른 스레드에 의해 획득된 상태라면, 해당 스레드는 잠금이 해제될 때까지 **대기** (`Blocking`)
  3. 잠금을 획득한 스레드만이 임계 구역에 들어갈 수 있음
  4. 임계 구역에서의 작업이 끝나면 반드시 `release` (잠금 해제)를 해야 함
     
* **특징:**
    * **이진(Binary) 상태:** 잠겨있음(Locked/1) 또는 풀려있음(Unlocked/0)의 두 가지 상태
    * **소유권(Ownership):** 잠금을 획득한 스레드만이 해당 잠금을 해제할 수 있음 (화장실에 들어간 사람이 직접 문을 열고 나와야 함)
      
* **주요 사용처:** **하나의** 공유 자원에 대한 **완전한 상호 배제**가 필요할 때 사용 → 가장 기본적이고 흔하게 사용되는 동기화 기법

---

### **2. 세마포 (Semaphore)**

**핵심 개념:** 열쇠가 **여러 개** 있는 화장실 칸

* **동작 방식:**
  1. 세마포는 특정 개수의 **자원(Permit)을 가진 카운터**로 초기화
  2. 임계 구역에 진입하려는 스레드는 `wait` (또는 `P` 연산)를 통해 카운터를 1 감소
  3. 만약 카운터가 0보다 크면 즉시 진입하고, 0이면 카운터가 1 이상이 될 때까지 **대기**
  4. 임계 구역에서 나오면 `signal` (또는 `V` 연산)을 통해 카운터를 1 증가시켜 다른 스레드가 사용할 수 있도록 함
     
* **특징:**
    * **카운팅(Counting) 상태:** 0 이상의 정수 값을 가질 수 있음 (사용 가능한 자원의 개수)
    * **소유권 없음:** 잠금을 획득한 스레드가 아니더라도 다른 스레드가 `signal`을 통해 카운터를 증가시킬 수 있음  
      → (내가 화장실에서 나왔다고 친구가 대신 열쇠를 반납할 수 있음)
      
* **종류:**
    * **카운팅 세마포 (Counting Semaphore):** `N > 1`인 경우. `N`개의 스레드가 동시에 공유 자원에 접근할 수 있음 (ex: 데이터베이스 커넥션 풀)
    * **이진 세마포 (Binary Semaphore):** `N = 1`인 경우. 뮤텍스처럼 동작하지만, 소유권 개념이 없다는 차이가 있음
      
* **주요 사용처:** **여러 개**의 동일한 자원에 대해 **동시 접근 가능한 스레드 수를 제한**하거나, 특정 작업의 **실행 순서를 제어**할 때 사용

---

### **3. 모니터 (Monitor)**

**핵심 개념:** **관리인**(규칙)이 있는 화장실 (뮤텍스 + 조건 변수)

* **동작 방식:**
    * 뮤텍스와 **조건 변수**(Condition Variable)를 함께 캡슐화한 **고수준 동기화 구조체**
    * 프로그래머는 복잡한 `acquire`/`release` 로직을 직접 짤 필요 없이, 모니터가 제공하는 규칙 안에서 코드를 작성하면 됨
    * **뮤텍스:** 모니터 내의 데이터에 오직 하나의 스레드만 접근하도록 보장 (상호 배제)
    * **조건 변수:** 특정 조건이 충족될 때까지 스레드를 **대기(`wait`)**시키거나, 대기 중인 스레드를 **깨우는(`signal`, `notify`)** 역할
      
* **특징:**
    * **사용 편의성:** 뮤텍스와 세마포의 잠재적인 오류(ex: 잠금 해제 누락)를 줄여주고, 더 안전하고 쉽게 동기화 코드를 작성할 수 있게 해줌
    * **언어 수준 지원:** Java의 `synchronized` 블록과 `wait()`, `notify()` 메서드가 대표적인 모니터 구현체
      
* **주요 사용처:** 복잡한 동기화 시나리오, 특히 **'생산자-소비자'** 문제와 같이 특정 조건에 따라 스레드 간의 실행 순서를 정교하게 제어할 때

---

### **추가 인사이트**

1.  **"어떤 것을 써야 하는가?"**
    * **가장 먼저 `Mutex`(또는 언어가 제공하는 Lock)를 고려하자!**  
      → 대부분의 상호 배제 문제는 뮤텍스로 간단하고 명확하게 해결됨  
      → "이 코드 블록은 한 번에 하나만 실행되어야 한다"는 명제가 참이면 뮤텍스인 셈  
      
    * **동시에 접근 가능한 스레드 수를 제한해야 한다면 `Semaphore`를 사용하자!**  
      → 대표적인 예가 **DB 커넥션 풀(Connection Pool) 관리**임  
      → 가용 커넥션 개수를 세마포 카운터로 설정하고, 스레드는 커넥션을 얻을 때 `wait`, 반납할 때 `signal`을 호출하는 방식으로 구현 가능함  
      
    * **복잡한 조건부 대기/알림이 필요하면 `Monitor`를 사용하자!**  
      → 예를 들어, "작업 큐(Task Queue)에 데이터가 있을 때만 소비자가 일을 하고, 데이터가 없으면 기다려야 한다"와 같은 시나리오에 적합함  
      → Java에서는 `synchronized`와 `wait/notify`를 통해 자연스럽게 구현 가능함

2.  **성능과 교착 상태 (Deadlock)**
    * **Lock의 범위(Scope)는 최대한 좁게 잡자!**  
      → `acquire`와 `release` 사이의 코드, 즉 임계 구역은 최대한 짧아야 함  
      → 임계 구역이 길어지면 다른 스레드들의 대기 시간이 늘어나 전체 시스템의 처리량(Throughput)이 떨어짐 
      
    * **교착 상태(Deadlock)를 항상 경계하자!**  
      → 두 개 이상의 스레드가 서로가 가진 락을 기다리며 무한 대기에 빠지는 상황임  
      → 교착 상태를 피하는 가장 간단한 규칙은 **락을 획득하는 순서를 항상 동일하게** 유지하는 것  
      → (예: 모든 스레드가 항상 Lock A -> Lock B 순서로만 획득하도록 강제)

3.  **Java와 Spring 개발자로서의 관점**  
    Java의 동시성(Concurrency) 패키지인 `java.util.concurrent`를 깊게 파보는 것을 추천  
    단순 `synchronized`, `ReentrantLock`(더 유연한 뮤텍스), `Semaphore`, `CountDownLatch`, `CyclicBarrier` 등  
    특히 `@Transactional` 사용 시, Spring이 어떻게 DB 트랜잭션을 통해 **데이터의 원자성(Atomicity)과 일관성(Consistency)을 보장하는지**  
    > 이 또한 넓은 의미에서 동기화의 한 형태이며, 여러 요청이 동시에 재고를 차감하려 할 때 데이터 정합성을 지켜주는 원리는 본 내용과 연관됨
