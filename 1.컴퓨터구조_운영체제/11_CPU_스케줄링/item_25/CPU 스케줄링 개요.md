## 11-1 CPU 스케줄링 개요

### 운영체제는 CPU를 어떻게 프로세스에 배분하는가?


### CPU 스케줄링

- 운영체제가 프로세스들에게 공정하고 합리적으로 CPU자원을 배분하는 것

### 일반적인 프로세스의 실행 과정

대부분의 프로세스들은 CPU와 입출력 장치를 모두 사용하며 실행된다.

→ 프로세스는 실행 상태와 대기 상태를 반복하며 실행된다.

<aside>


> CPU 버스트 : CPU를 이용하는 작업

> 입출력 버스트 : 입출력 장치를 기다리는 작업


</aside>

- 입출력 집중 프로세스
    - 입출력 작업이 많은 프로세스
    - 실행 상태보다 입출력을 위한 대기 상태에 더 많이 머무른다.
    - Ex) 비디오 재생 or 디스크 백업 작업을 담당하는 프로세스 등

- CPU 집중 프로세스
    - CPU작업이 많은 프로세스
    - 대기 상태보다 실행 상태에 더 많이 머무른다.
    - Ex) 복잡한 수학 연산 or 컴파일 등

→ 실행 상태와 대기 상태는 프로세스의 상태를 의미한다.

⇒ CPU 집중 프로세스와 입출력 집중 프로세스가 모두 동일한 빈도로 CPU를 사용하는 것은 비합리적

<br>

예를 들어, CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU 자원을 요구한다면,

입출력 집중 프로세스를 가능한 한 빨리 실행시켜 입출력 장치를 끊임없이 작동 시키고,

그 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 더 효율적이다.

> IO 입출력 장치와 CPU는 독립적으로 작동하기 때문에,
입출력 집중 프로세스가 CPU를 잠깐 쓰고 다른 프로세스에게 양도가 가능하다.

### 프로세스 우선 순위

상황과 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 **우선 순위**를 부여한다.

운영체제는 각 프로세스의 PCB에 우선 순위를 명시한다.

PCB에 우선순위가 적혀있지만, OS가 모든 프로세스의 PCB를 찾는 것은 비효율적이다.

→ 스케줄링 큐를 통해 운영체제가 프로세스를 관리한다.

---

### 스케줄링 큐

- 운영체제(OS)에서 프로세스들을 관리할 때 대기열(Queue) 형태로 다루는 구조

### 대표적인 큐

- 준비 큐 (Ready Queue)
    - CPU를 이용하고 싶은 프로세스들을 관리한다.
    - 프로세스들의 PCB가 들어간다.
- 대기 큐 (Waiting Queue)
    - 입출력 장치를 이용하기 위해 대기 상태에 접어든 프로세스들을 관리한다.

---

### 선점형과 비선점형 스케줄링

- 선점형 스케줄링
    - 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식
    - 장점
        - 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다.
    - 단점
        - 문맥 교환 과정에서 오버헤드가 발생할 수 있다.

- 비선점형 스케줄링
    - 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전 까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식
    - 장점
        - 문맥 교환 횟수가 선점형 스케줄링보다 적어 오버헤드가 적다.
    - 단점
        - 모든 프로세스가 골고루 자원을 사용할 수 없다.

<aside>


> Context Switching (문맥 교환)
>
> CPU가 현재 실행 중인 프로세스(또는 스레드)의 상태를 저장하고, 다른 프로세스의 상태를 불러와 실행을 전환하는 과정

</aside>
