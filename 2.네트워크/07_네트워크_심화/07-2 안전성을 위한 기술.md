## 네트워크 보안과 암호화 (Security)

### 1. 암호화 방식의 진화
> 현대 웹 보안은 속도와 안전성을 모두 잡기 위해 대칭키와 공개키 방식을 혼합해서 사용합니다.

#### 대칭키 암호화 (Symmetric Key)
* **개념:** 암호화할 때 쓰는 키와 복호화할 때 쓰는 키가 **동일한** 방식.
* **장점:** 연산 속도가 매우 빠르며 대용량 데이터 처리에 적합합니다. (예: AES)
* **단점(키 배송 문제):** 상대방에게 키를 전달해야 하는데, 이 과정에서 키가 탈취되면 모든 보안이 뚫립니다.
* **세션 키 (Session Key):** 통신이 연결되어 있는 동안(세션)에만 사용하는 일회용 대칭키입니다. TLS에서 실제 데이터를 암호화할 때 사용합니다.

#### 공개키(비대칭키) 암호화 (Public Key)
* **개념:** 두 개의 키(**공개키**, **개인키**) 한 쌍을 사용합니다.
    * **공개키(Public Key):** 모두에게 공개. (잠그는 용도)
    * **개인키(Private Key):** 나만 소유. (여는 용도)
* **작동 원리:** A가 B의 '공개키'로 암호화해서 보내면, B는 자신의 '개인키'로만 해석할 수 있습니다.
* **장점:** 키를 주고받을 필요가 없어 보안성이 높습니다.
* **단점:** 수학적 연산이 복잡해 대칭키보다 속도가 훨씬 느립니다.

---

### 2. 인증과 서명 (Authentication & Signature)

#### 디지털 서명 (Digital Signature)
* **개념:** 공개키 암호화를 **반대로** 이용한 기술입니다. "내가 보낸 게 맞다"는 것을 증명합니다.
* **원리:**
    1. 보내는 사람이 자신의 개인키로 암호화(서명)해서 보냅니다.
    2. 받는 사람은 보낸 사람의 **공개키로 복호화**를 시도합니다.
    3. 복호화가 성공하면? -> "아, 이 문서는 그 사람의 개인키로 잠긴 게 맞구나(신원 확인) + 내용이 변조되지 않았구나(무결성)"를 인증합니다.

#### 공개키 인증서 (Public Key Certificate)
* **문제점:** 해커가 가짜 공개키를 진짜인 척 속일 수 있습니다.
* **해결:** 신뢰할 수 있는 제3자 기관(**CA**)이 "이 공개키는 진짜 구글(Google)의 것이 맞습니다"라고 보증해주는 전자 문서입니다.

#### WebAuthn (웹 인증 & 패스워드리스)
* **개념:** 요즘 많이 보이는 '지문 로그인', 'FaceID 로그인', 'Passkeys'의 기술적 표준입니다. **비대칭키 암호화의 대표적 활용 사례**입니다.
* **작동 방식:**
    1. 사용자 기기(스마트폰 등) 안전한 영역에 **개인키**를 생성하고 저장합니다.
    2. 서버에는 **공개키**만 등록해 둡니다.
    3. 로그인 시 서버가 퀴즈(Challenge)를 내면, 사용자는 생체인증 후 **개인키로 서명**해서 답을 보냅니다.
    4. 서버는 공개키로 확인만 합니다.
* **장점:** **비밀번호가 네트워크를 타고 전송되지 않아** 탈취될 위험이 없습니다.

---

### 3. 안전한 웹 통신 (HTTPS & TLS)

#### SSL / TLS
* **SSL (Secure Sockets Layer):** 웹 보안 프로토콜의 원조 (현재는 보안 취약점으로 사용 중단).
* **TLS (Transport Layer Security):** SSL을 계승하여 표준화된 현재의 보안 프로토콜.
* **HTTPS:** HTTP 프로토콜 위에 SSL/TLS 보안 계층을 얹은 것. (데이터를 암호화해서 전송)

#### TLS 핸드셰이크 (TLS Handshake)
> "공개키로 안전하게 만나서, 대칭키를 나눠 갖고, 대칭키로 빠르게 통신하자!"

1. **Client Hello:** 클라이언트가 서버에 접속 요청 (사용 가능한 암호화 방식 등 전달).
2. **Server Hello:** 서버가 인증서(공개키 포함)를 클라이언트에게 전달.
3. **검증:** 클라이언트는 CA를 통해 서버의 인증서가 진짜인지 확인.
4. **키 교환 (핵심):** 클라이언트는 **서버의 공개키**를 이용해 임시 비밀값(Pre-Master Secret)을 암호화해서 서버에 보냅니다.
5. **세션키 생성:** 양쪽은 이 비밀값을 바탕으로 동일한 세션키(대칭키)를 생성합니다.
6. **통신 시작:** 이후 데이터 전송은 빠른 **세션키**로 암호화하여 주고받습니다.
