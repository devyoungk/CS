# 3. TCP의 오류·흐름·혼잡 제어

TCP의 신뢰성 보장하기 위한 오류 제어, 흐름 제어, 혼잡 제어

## 오류 제어: 재전송 기법

TCP는 오류 제어를 위해 잘못된 세그먼트를 재전송하는 방법 사용

#### 오류 검출과 재전송

TCP가 어떤 상황에서 송신한 세그먼트에 문제가 있음을 감지할까?
  1. 중복된 ACK 세그먼트를 수신했을 때
      - 수신 호스트가 받은 세그먼트 순서 번호 중 일부 누락 → 중복된 ACK 전송
  2. 타임아웃이 발생했을 때
      - **타임 아웃** : **재전송 타이머**의 정해진 시간이 끝난 상황

※ 참고  
RTT : 메시지를 전송한 뒤 그에 대한 답변을 받는 데까지 걸리는 시간

#### ARQ: 재전송 기법

**ARQ** : 자동 재전송 요구

- **Stop-and-Wait ARQ**
    - 제대로 전달했음을 확인하기 전까지 새로운 메시지를 보내지 않는 방식
    - 높은 신뢰성 보장 / 네트워크 이용 효율 낮아질 수 있어
- **Go-Back-N ARQ**
    - 파이프라이닝 방식을 활용해 여러 세그먼트를 전송하고, 도중에 잘못 전송된 세그먼트가 발생할 경우 해당 세그먼트부터 다시 전송하는 방식  
      (파이프라이닝: 연속해서 메시지를 전송할 수 있는 기술)
    - ACK 세그먼트 → **누적 확인 응답**
- **SELECTIVE Repeat ARQ**
    - 수신 호스트 측에서 제대로 전송받은 각각의 패킷들에 대해 ACK 세그먼트를 보내는 방식
    - ACK 세그먼트 → **개별 확인 응답**

---

## 흐름 제어: 슬라이딩 윈도우

호스트가 한 번에 받아서 처리할 수 있는 세그먼트의 양에 한계 있음

**수신 버퍼** : 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시로 저장되는 공간

**윈도우** : 송신 호스트가 파이프라이닝할 수 있는 최대량. 윈도우의 크기만큼 확인 응답을 받지 않고도 한 번에 전송 가능

**슬라이딩 윈도우** : 파이프라이닝 과정에서 송수신 윈도우가 점차 미끄러지듯 움직여 흐름 제어

---

## 혼잡 제어

**혼잡** : 많은 트래픽으로 인해 패킷의 처리 속도가 늦어지거나 유실될 우려가 있는 네트워크 상황

**혼잡 윈도우** : 혼잡 없이 전송할 수 있을 법한 데이터의 양

크기는 어느 정도가 좋을까? → **혼잡 제어 알고리즘**을 통해 결정

**AIMD** : Additive Increase/Multiplicative Decrease (합으로 증가, 곱으로 감소)

→ 혼잡 감지 X : 혼잡 윈도우 1씩 증가, 혼잡 감지 : 혼잡 윈도우 절반으로

⇒ 이는 혼잡을 제어할 수 있는 가장 기본적인 아이디어지만, 이것만으로 혼잡 제어 이루어지지 않는다.

#### 1. 느린 시작 알고리즘
혼잡 윈도우를 1부터 시작해 문제없이 수신된 ACK 세그먼트 하나당 1씩 증가  
언제까지? -> **느린 시작 임계치**

#### 2. 혼잡 회피 알고리즘
RTT마다 혼잡 윈도우를 1MSS씩 증가

#### 3. 빠른 회복 알고리즘
세 번의 중복 ACK 세그먼트를 수신했을 때 느린 시작 건너뛰고 혼잡 회피 수행

| 상황 분류 | 방법 |
| --- | --- |
| 타임아웃 발생 | 혼잡 윈도우 값을 1로, 느린 시작 임계치를 혼잡이 감지되었을 시점의 혼잡 윈도우 값의 절반으로 초기화한 뒤 **느린 시작 재개** |
| 혼잡 윈도우 ≥ 느린 시작 임계치 | 느린 시작 종료, 혼잡 윈도우를 절반으로 초기화한 뒤 **혼잡 회피** 수행 |
| 세 번의 중복 ACK 발생 | (빠른 재전송 후) **빠른 회복** 수행 |
