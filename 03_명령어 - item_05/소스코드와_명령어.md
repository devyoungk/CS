# 3-1 소스 코드와 명령어

모든 소스 코드는 컴퓨터 내부에서 명령어로 변환된다.
이번 절에서는 프로그래밍 언어가 어떻게 명령어가 되어 실행되는지 알아본다.

## 고급 언어와 저급 언어

**컴퓨터는 어떻게 프로그래밍 언어를 이해할까?**

우리가 프로그램을 만들 때 사용하는 프로그래밍 언어는 컴퓨터가 이해하는 언어가 아닌 사람이 이해하고 작성하기 쉽게 만들어진 언어이다. 이러한 사람을 위한 언어를 **‘고급 언어’**라고 한다. 반대로 컴퓨터가 직접 이해하고 실행할 수 있는 언어를 **‘저급 언어’**라고 한다.

저급 언어는 명령어로 이루어져 있다. 컴퓨터가 이해하고 실행할 수 있는 언어는 오직 저급 언어 뿐이다. 이 때문에 고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어로 변환하는 과정이 필요하다.

### 저급 언어의 두 가지 종류

저급 언어에는 **기계어**와 **어셈블리어**, 두 가지 종류가 있다.

#### 기계어란?
0과 1의 명령어 비트로 이루어진 명령어 모음이다. (기계어를 이진수로 나열하면 너무 길어지기 때문에 16진수로 표현하기도 한다.)

기계어를 사람이 보게 되면 이 기계어가 무엇을 뜻하고, 이 기계어가 컴퓨터를 어떻게 작동시키는지 분간하기 어렵다. 그래서 등장한 저급 언어가 어셈블리어이다.

> **기계어는 0과 1의 명령어 비트로 이루어져 있다. 이를 읽기 편한 형태로 번역한 언어가 어셈블리어이다.**
>
> *예시) `0101 0101` (기계어) → `push rbp` (어셈블리어)*

어셈블리어는 0과 1로 이루어진 기계어를 읽기 편하게 만든 저급 언어일 뿐이므로, 개발자가 어셈블리어를 이용해 복잡한 프로그램을 만들기란 쉽지 않다.

**→ 어떤 부분이 어려운지 감이 잘 안 잡힌다. 구체적으로 어떤 부분이 어려울까?**

그 이유는 어셈블리어가 기계어에 너무 가깝다는 것을 들 수 있다. 모든 것을 아주 세세하고 기계적인 관점에서 직접 제어해야 하므로 생산성이 낮고 오류가 발생하기 쉽다.

예를 들어보자. `a = b + c`를 보면 고급 언어에서는 한 줄로 끝나지만 어셈블리어에서는 여러 단계로 나뉘게 된다.


1. b의 값을 메모리에서 CPU 레지스터로 가져와라.
MOV EAX, [b]

2. c의 값을 메모리에서 다른 CPU 레지스터로 가져와라.
MOV EBX, [c]

3. 두 레지스터의 값을 더해라.
ADD EAX, EBX

4. 결과가 저장된 레지스터의 값을 다시 a의 메모리 주소로 옮겨라.
MOV [a], EAX

이를 보면 추상화 수준이 극단적으로 낮은 걸 알 수 있다. 또 어셈블리어는 하드웨어에 대한 깊은 이해가 필요하다. 어셈블리어는 **특정 CPU 아키텍쳐에 종속적**이다. 따라서 프로그램을 작성하려면 CPU의 종류, 레지-스터의 개수와 종류, 메모리 주소 지정 방식 등 하드웨어에 대한 해박한 지식이 필요하다. 이 때문에 **이식성이 없다**는 치명적인 단점도 발생한다. 예를 들어 PC용으로 작성한 어셈블리어 코드는 스마트폰에서 전혀 작동하지 않을 수도 있다.

고급 언어를 사용하면 읽고 쓰기가 편하고, 변수나 함수 같은 편리한 문법을 제공하기 때문에 복잡한 프로그램도 구현이 가능하다.

### 그러면 왜 저급 언어를 알아야 할까?

어셈블리어를 작성할 일이 없을 수도 있지만 하드웨어와 밀접하게 맞닿아 있는 프로그램을 개발하는 **임베디드 개발자, 게임 개발자, 정보 보안 분야** 등의 개발자는 아래와 같이 어셈블리어를 많이 이용하게 된다.

**→ 왜? 왜 하드웨어와 밀접하게 닿아있으면 고급언어를 쓰지 않고 어셈블리어를 사용할까?**

고급 언어는 개발자가 편하도록 만들어진 추상화된 도구이기 때문에, 하드웨어의 세세한 부분까지 직접 제어하는 데에 한계가 존재하기 때문이다.

#### 첫 번째로 하드웨어의 직접 제어에 관해서이다.
고급 언어는 “A라는 변수에 10을 저장해줘”라고 명령하면 컴파일러가 알아서 최적의 메모리 주소나 CPU 레지스터를 찾아 할당하게 된다. 개발자는 이 과정에 관여할 수 없게 된다. 하지만 특정 하드웨어를 제어하려면 메모리 주소와 CPU 레지스터를 직접 정의하여 명령해야 한다.

조금 더 자세히 설명하자면, 키보드, 마우스, 그래픽 카드 같은 장치들은 각각 고유의 메모리 주소와 제어 신호를 가진다. 고급 언어로는 이 특정 하드웨어 주소에 직접 접근하는 것이 불가능하거나 매우 비효율적이다. 어셈블리어만이 이 하드웨어 장치들을 직접 연결할 수 있다.

또 컴퓨터의 전원을 끄고 켰을 때를 생각해보자. 운영체제가 실행되기 전의 상태이므로 CPU를 초기화하고 메모리 상태를 점검하는 등의 작업은 CPU에게 직접 명령을 내릴 수 있는 어셈블리어만이 가능하다.

#### 두 번째로 성능의 최적화 부분을 생각했을 때이다.
> 성능의 최적화? 컴파일러가 알아서 최적의 메모리 주소나 CPU 레지스터를 찾아 할당한다고 하지 않았나?

라고 생각할 수 있다. 하지만 성능이 조금이라도 더 중요하고 매 순간 매우 많이 반복되는 **핵심 코드**에서는 이야기가 달라진다.

캐시를 예로 들어보자. CPU가 메모리에서 데이터를 가져오는 속도는 CPU 연산 속도에 비해 매우 느리다. 그래서 CPU는 아주 작은 초고속 임시 저장소인 **캐시**를 사용한다. 컴파일러는 일반적인 규칙에 따라 캐시를 활용하지만, 개발자는 프로그램의 데이터 흐름을 정확히 알고 있기 때문에, 어떤 데이터를 언제 캐시에 올려놓고 언제 접근해야 가장 효율적인지 수작업으로 설계할 수 있다. 메모리 접근 횟수를 단 한 번이라도 줄이는 것은 성능 향상으로 이어질 수 있다.

결론적으로 성능 최적화는 컴파일러가 못하는 것이 아닌, 컴파일러는 보편적인 최적화를 진행하지만 어셈블리어를 통한다면 특정 목적을 위한 **극한의 최적화**가 가능하기 때문이다.

#### 마지막으로 자원 사용에 관한 부분이다.
우리가 쓰는 PC나 스마트폰과 달리 메모리가 부족한 초소형 컴퓨터(IoT 센서 등)들이 많다. 고급 언어는 편리한 기능을 제공하기 위해 기본적인 실행 환경이나 라이브러리를 필요로 한다. 이런 부가적인 요소들이 작은 기기에는 부담이 되므로 어셈블리어를 사용하는 것이 이점이 된다.

이러한 분야의 개발자들에게 어셈블리어란 작성의 대상일 뿐 아니라 매우 중요한 **관찰의 대상**이다. 어셈블리어를 읽으면 컴퓨터가 프로그램을 어떤 과정으로 실행하는지, 즉 프로그램이 어떤 절차로 작동하는지를 가장 근본적인 단계에서 추적하고 관찰할 수 있기 때문이다.

---

## 컴파일 언어와 인터프리터 언어

개발자들이 고급 언어로 작성한 코드는 결국 저급 언어로 변환되어 실행된다.

**그렇다면 고급 언어는 어떻게 저급 언어로 변환될까?**

여기에는 크게 두 가지, **컴파일 방식**과 **인터프리트 방식**이 있다. 컴파일 방식으로 작동하는 프로그래밍 언어를 **컴파일 언어**, 인터프리트 방식으로 작동하는 프로그래밍 언어를 **인터프리터 언어**라고 한다.

### 컴파일 언어
컴파일 언어는 **컴파일러**에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어이다. 대표적인 컴파일 언어로는 C가 있다.

소스 코드 전체가 저급 언어로 변환되는 과정을 **컴파일**이라고 한다. 그리고 컴파일을 수행해주는 도구를 **컴파일러**라고 한다. 컴파일러는 소스 코드에 문법적인 오류는 없는지, 실행 가능한 코드인지, 실행 하는데 불필요한 코드는 없는지 등을 따지며 소스 코드 처음부터 끝까지 저급 언어로 컴파일한다. 이때 컴파일러가 오류를 하나라도 발견하면 컴파일에 실패한다.

**→ 어떤 방식으로 따지는 걸까?**
컴파일러는 여러 단계를 거치며 코드를 분석하는데, 각 단계마다 정해진 규칙을 바탕으로 오류를 찾아낸다. 크게 **어휘, 구문, 의미** 세 가지 관점에서 코드를 검사한다. (컴파일러의 과정은 맨 밑에 간략히 서술하겠다.)

컴파일이 성공적으로 수행되면 개발자가 작성한 소스 코드는 컴퓨터가 이해할 수 있는 저급 언어로 변환된다. 이렇게 변환된 코드를 **목적 코드**라고 한다.

### 인터프리터 언어
인터프리터 언어는 **인터프리터**에 의해 소스 코드가 한 줄씩 실행되는 고급 언어이다. 대표적으로 Python이 있다.

소스 코드 전체가 저급 언어로 변환되는 컴파일 언어와는 달리, 인터프리터 언어는 소스 코드를 한 줄씩 차례로 실행한다. 그리고 소스 코드를 한 줄씩 저급 언어로 변환하여 실행해주는 도구를 **인터프리터**라고 한다.

인터프리터 언어는 컴퓨터와 대화하듯 소스 코드를 한 줄씩 실행하기 때문에 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없다. 그리고 소스 코드 내에 오류가 하나라도 있으면 컴파일이 불가능 했던 컴파일 언어와는 달리, 인터프리터 언어는 소스 코드를 한 줄씩 실행하기 때문에 소스 코드 N번째 줄에 오류가 있더라도 그 전까지는 올바르게 수행된다.

인터프리터 언어가 컴파일 언어보다 빠르다고 생각할 수도 있지만, 일반적으로 인터프리터 언어는 컴파일 언어보다 **느리다**. 목적 코드는 컴퓨터가 이해하고 실행할 수 있는 저급 언어인 반면, 인터프리터 언어는 소스 코드 마지막에 이를 때까지 한 줄 한 줄 씩 저급 언어로 해석하며 실행해야 하기 때문이다. (*코드 실행 시간을 보면 C와 Python을 비교했을 때 C가 압도적으로 빠른 것을 볼 수 있다.*)

### 컴파일 언어와 인터프리터 언어를 명확히 구분할 수 있는가?
현대의 많은 프로그래밍 언어 중에는 컴파일 언어와 인터프리터 언어 간의 경계가 모호한 경우가 많다. 가령 대표적인 인터프리터 언어로 알려진 파이썬도 컴파일을 하지 않는 것은 아니며, Java의 경우 저급 언어가 되는 과정에서 컴파일과 인터프리터를 동시에 수행한다.

> **하나의 프로그래밍 언어가 반드시 둘 중 하나의 방식만으로 작동한다고 생각하는 것은 오개념이다.**

**→ Java의 경우 어떤 식으로 동시에 수행하면서 저급 언어로 변환되는걸까?**
Java에는 "한 번 작성하면 어디서든 실행된다(Write Once, Run Anywhere)" 라는 목표가 있다. 이를 위해 소스 코드를 먼저 중간 언어인 **바이트코드**로 컴파일하고, 이 바이트 코드를 각 운영체제에 맞는 **자바 가상 머신(JVM)**이 인터프리터 방식과 **JIT 컴파일** 방식을 혼합하여 실행한다.

과정으로 나타내보자.

#### 1. 소스 코드 → 바이트 코드 (정적 컴파일)
개발자가 작성한 자바 소스 코드는 `javac` 라는 컴파일러를 통해 먼저 번역된다. 하지만 이 때 번역된 결과물은 기계어가 아니라, JVM이 이해할 수 있는 중간 언어인 **바이트코드** 파일이다. 이 바이트 코드는 윈도우, 맥, 리눅스 구분이 없는 플랫폼 독립적 코드이다.

#### 2. 바이트 코드 실행
사용자가 프로그램을 실행하면, 각 운영체제에 설치된 JVM이 바이트 코드 파일을 실행시킨다. 이 과정에서 두 가지 방식을 사용하게 된다.

- **초기 실행 : 인터프리터**
  프로그램이 시작되면, JVM의 인터프리터는 바이트 코드를 한 줄씩 읽어 해석하며 실행을 시작한다. (*→ 기계어로 전부 번역될 때까지 기다리지 않고 프로그램이 빨리 시작된다.*)

- **성능 최적화 : JIT 컴파일러**
  인터프리터가 코드를 실행하는 동안, JVM은 어떤 코드가 자주 반복해서 사용되는지를 분석한다. (*자주 반복해서 사용되는 곳 → Hot Spot이라고 칭함*) 자주 사용되는 **핫스팟(Hot Spot)** 코드가 발견되면 **JIT(Just-In-Time) 컴파일러**가 이 부분의 바이트 코드를 실행하는 시점에 해당 운영체제가 가장 잘 이해할 수 있는 기계어로 번역한다. 그 이후부터는 해당 코드를 실행할 때 인터프리터를 거치지 않고 미리 번역해둔 기계어 코드를 실행하는 것이다.

> **이식성 & 성능 모두 챙길 수 있게 되었다.**

---

## 목적 파일 / 실행 파일

**목적 코드**로 이루어진 파일은 **목적 파일**이라고 부른다. 마찬가지로 **실행 코드**로 이루어진 파일을 **실행 파일**이라고 부른다. 목적 코드가 실행 파일이 되기 위해서는 **링킹(Linking)**이라는 작업을 거쳐야 한다.

### 링킹(Linking)이란 무엇인가?

**링킹(Linking)**이란 컴파일러가 생성한 여러 개의 오브젝트 파일(목적 파일)과 라이브러리 파일을 하나로 합쳐, 운영체제가 실행할 수 있는 하나의 완전한 실행 파일로 만드는 과정이다.

#### 링킹의 필요성
현대의 프로그램은 유지보수와 협업의 효율성을 위해 여러 개의 소스 파일로 나누어 개발된다. 컴파일러는 한 번에 하나의 소스 파일만 처리하므로, `main.c`를 컴파일할 때는 다른 소스 파일에 정의된 함수나 라이브러리에 있는 함수의 실제 위치를 알지 못한다. 따라서 컴파일러는 그저 특정 함수가 필요하다는 표시만 남겨둔 채, 미완성된 기계어 코드인 오브젝트 파일을 생성한다. 링킹은 이처럼 분리된 코드 조각들을 연결하여 완전한 프로그램을 만들기 위해 반드시 필요한 과정이다.

#### 링커의 역할과 과정
링커는 흩어져 있는 오브젝트 파일들을 모아 서로 연결하고 빠진 부분을 채워 넣는 역할을 수행한다. 이 과정은 크게 두 가지 핵심 작업으로 나뉜다.

1.  **심볼 해석 (Symbol Resolution)**
    링커는 각 오브젝트 파일에 남겨진 표시(심볼)를 확인하고, 다른 파일이나 라이브러리에서 해당 심볼의 실제 메모리 주소를 찾아 연결한다.

2.  **재배치 (Relocation)**
    각 오브젝트 파일은 자신이 메모리의 0번지에서 시작한다고 가정하고 만들어진다. 링커는 이 여러 오브젝트 파일들을 하나의 실행 파일로 합치면서 각 조각이 최종적으로 위치할 주소를 결정한다. 이후, 각 조각 내부의 코드들이 변경된 주소에 맞게 올바르게 동작하도록 내부 메모리 주소들을 수정하고 재조정한다.

이 모든 과정이 성공적으로 끝나면, 비로소 우리가 실행할 수 있는 하나의 완전한 프로그램이 만들어진다.